\FloatBarrier
[Dad got this far]
\section{NEAREST KIFMM Hybrid}
The advantage of the KIFMM method comes from its fast approximation of distant source points, while Nearest leverages the  differences in the rate of change of the single layer stokeslet kernel to approximate the kernel across the whole domain with less source points. If these methods were to be combined it would allow for even more efficient approximation of source points in the far field and an improvement to near field calculations. Given that the reduction in source points is enough to create a smaller Octree, particularly when a non adaptive tree is used, the KIFMM method should be able to compute the matrix problem in a shorter period of time. The adaption of the KIFMM method to use the nearest neighbour interpolation is a simple but fundamental change to the algorithm. When creating the Octree decomposition of the domain we form the tree based on target points and coarse source discretization as we would normally do, We then also generate the Nearest-Neighbour interpolation matrix $\nu$ defined in \cref{eq:NNMatrix} between the coarse source points and the fine quadrature rule.  

In the upwards pass when calculating the upwards equivalent potential we replace the right hand side of \cref{eq:upsum} with a nearest neighbour interpolation
\begin{equation*}
    \sum_{{\bm{y}}_{n} \in B} \bm{f}_{n}({\bm{y}}_n) \sum_{q=1}^{Q^*}S^{\epsilon}\left({\bm{q}}^{BD}_{k}, {\bm{X}}_{q}\right) \nu^*[q,n]
\end{equation*}
We define $\nu^*[q,n]$ as the subset of the full Nearest-neighbour matrix $\nu[q,n]$ corresponding to the map between points ${\bm{X}}_{q}$ and ${\bm{y}}_{n} \in B$. $Q^*$ is the number of fine quadrature points which map to ${\bm{y}}_{n} \in B$. This method provided a accurate approximation of the source points onto the upward equivalent surfaces. The use of Nearest-Neighbour interpolation in both the M2M translation (\cref{eq:M2M}) and the M2L translation (\cref{eq:M2L}) is not considered due to the need to compute the Nearest-Neighbour matrix between all boxes. While the interactions between boxes are computed during the Octree generation and the matrices could be precomputed, the number and size of these matrices make it inefficient to compute before hand, particularly when nodes with small number's of source points are considered. 
In the downwards pass we can also implement Nearest-Neighbour interpolation when looking at the interaction lists of a node $B$, both $I_X^B$ and $I_U^B$ consider point to point interactions directly due to them being in $\mathcal{N}(B)$. These translations are done through \cref{eq:X,eq:U} respectively. We now replace The right hand side with 
\begin{equation*}
    \sum_{A_i \in I_X^B} \sum_{{\bm{y}}_n\in A_i} {\bm{f}}_{n} \sum_{q=1}^{Q^*} S^\epsilon\left(\bm{q}^{BU}_{k}, {\bm{X}}_{q}\right) \nu^*[q,n], \quad k=1,\dots,N_q
\end{equation*}
and
\begin{equation*}
    \sum_{{\bm{y}}_n\in A}{\bm{f}}_n \sum_{q=1}^{Q^*} S^\epsilon(\bm{x},{\bm{X}}_q) \nu^*[q,n]
\end{equation*}
respectively. Where $\nu^*[q,n]$ again corresponds to a slice of $\nu[q,n]$ which contain respective map between source points and fine quadrature points in each summation.